# soundcloud-widget-react — Full Reference

React component library wrapping the SoundCloud HTML5 Widget API with full TypeScript support.
Version: 1.0.8 | License: MIT | npm: soundcloud-widget-react

---

# src/types.ts
import type { CSSProperties } from "react";

export interface SCWidgetParams {
  autoPlay?: boolean;
  color?: string;
  buying?: boolean;
  sharing?: boolean;
  download?: boolean;
  showArtwork?: boolean;
  showPlaycount?: boolean;
  showUser?: boolean;
  startTrack?: number;
  singleActive?: boolean;
  showTeaser?: boolean;
}

export interface SCAudioEventPayload {
  relativePosition: number;
  loadProgress: number;
  currentPosition: number;
}

export interface SCSound {
  id: number;
  title: string;
  permalink_url: string;
  artwork_url: string | null;
  user: { username: string; permalink_url: string };
  duration: number;
}

export interface SCWidgetInstance {
  bind(eventName: string, listener: (e?: SCAudioEventPayload) => void): void;
  unbind(eventName: string): void;
  load(url: string, options?: Partial<SCWidgetParams> & { callback?: () => void }): void;
  play(): void;
  pause(): void;
  toggle(): void;
  seekTo(milliseconds: number): void;
  setVolume(volume: number): void;
  next(): void;
  prev(): void;
  skip(soundIndex: number): void;
  getVolume(callback: (volume: number) => void): void;
  getDuration(callback: (duration: number) => void): void;
  getPosition(callback: (position: number) => void): void;
  getSounds(callback: (sounds: SCSound[]) => void): void;
  getCurrentSound(callback: (sound: SCSound) => void): void;
  getCurrentSoundIndex(callback: (index: number) => void): void;
  isPaused(callback: (paused: boolean) => void): void;
}

export interface SCWidgetRef {
  play(): void;
  pause(): void;
  toggle(): void;
  seekTo(milliseconds: number): void;
  setVolume(volume: number): void;
  next(): void;
  prev(): void;
  skip(soundIndex: number): void;
  load(url: string, options?: Partial<SCWidgetParams> & { callback?: () => void }): void;
  getVolume(callback: (volume: number) => void): void;
  getDuration(callback: (duration: number) => void): void;
  getPosition(callback: (position: number) => void): void;
  getSounds(callback: (sounds: SCSound[]) => void): void;
  getCurrentSound(callback: (sound: SCSound) => void): void;
  getCurrentSoundIndex(callback: (index: number) => void): void;
  isPaused(callback: (paused: boolean) => void): void;
}

export interface SCWidgetProps extends SCWidgetParams {
  url: string;
  width?: string | number;
  height?: string | number;
  style?: CSSProperties;
  className?: string;
  iframeId?: string;
  onReady?: () => void;
  onPlay?: (e: SCAudioEventPayload) => void;
  onPause?: (e: SCAudioEventPayload) => void;
  onFinish?: (e: SCAudioEventPayload) => void;
  onSeek?: (e: SCAudioEventPayload) => void;
  onPlayProgress?: (e: SCAudioEventPayload) => void;
  onLoadProgress?: (e: SCAudioEventPayload) => void;
  onError?: () => void;
  onClickDownload?: () => void;
  onClickBuy?: () => void;
  onOpenSharePanel?: () => void;
}

---

# src/useScript.ts
import { useState, useEffect } from "react";

const SC_API_URL = "https://w.soundcloud.com/player/api.js";

let scriptPromise: Promise<void> | null = null;

function loadScript(): Promise<void> {
  if (scriptPromise) return scriptPromise;

  // Already loaded (e.g. via Next.js <Script strategy="beforeInteractive">)
  if (typeof window !== "undefined" && window.SC) {
    scriptPromise = Promise.resolve();
    return scriptPromise;
  }

  scriptPromise = new Promise<void>((resolve, reject) => {
    // Script tag already in DOM but not yet executed — wait for it
    const existing = document.querySelector<HTMLScriptElement>(
      `script[src="${SC_API_URL}"]`
    );
    if (existing) {
      // Poll until window.SC appears (script is cached/in-flight)
      const interval = setInterval(() => {
        if (window.SC) {
          clearInterval(interval);
          resolve();
        }
      }, 50);
      // Safety timeout after 10s
      setTimeout(() => {
        clearInterval(interval);
        reject(new Error("Timed out waiting for SoundCloud Widget API"));
      }, 10_000);
      return;
    }

    const script = document.createElement("script");
    script.src = SC_API_URL;
    script.async = true;
    script.onload = () => resolve();
    script.onerror = () => {
      scriptPromise = null;
      reject(new Error("Failed to load SoundCloud Widget API"));
    };
    document.head.appendChild(script);
  });

  return scriptPromise;
}

export function useScript(): { loaded: boolean } {
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined") return;

    loadScript()
      .then(() => setLoaded(true))
      .catch((err) => console.error(err));
  }, []);

  return { loaded };
}

---

# src/SCWidget.tsx
import React, {
  forwardRef,
  useEffect,
  useId,
  useImperativeHandle,
  useRef,
} from "react";
import { useScript } from "./useScript";
import type {
  SCAudioEventPayload,
  SCWidgetInstance,
  SCWidgetParams,
  SCWidgetProps,
  SCWidgetRef,
} from "./types";

declare global {
  interface Window {
    SC: {
      Widget: (iframe: HTMLIFrameElement) => SCWidgetInstance;
    };
  }
}

const PARAM_MAP: Array<[keyof SCWidgetParams, string]> = [
  ["autoPlay", "auto_play"],
  ["color", "color"],
  ["buying", "buying"],
  ["sharing", "sharing"],
  ["download", "download"],
  ["showArtwork", "show_artwork"],
  ["showPlaycount", "show_playcount"],
  ["showUser", "show_user"],
  ["startTrack", "start_track"],
  ["singleActive", "single_active"],
  ["showTeaser", "show_teaser"],
];

function buildIframeSrc(url: string, params: SCWidgetParams): string {
  const search = new URLSearchParams();
  search.set("url", encodeURIComponent(url));

  for (const [prop, urlKey] of PARAM_MAP) {
    const value = params[prop];
    if (value !== undefined) {
      search.set(urlKey, String(value));
    }
  }

  return `https://w.soundcloud.com/player/?${search.toString()}`;
}

function extractParams(props: SCWidgetProps): SCWidgetParams {
  return {
    autoPlay: props.autoPlay,
    color: props.color,
    buying: props.buying,
    sharing: props.sharing,
    download: props.download,
    showArtwork: props.showArtwork,
    showPlaycount: props.showPlaycount,
    showUser: props.showUser,
    startTrack: props.startTrack,
    singleActive: props.singleActive,
    showTeaser: props.showTeaser,
  };
}

export const SCWidget = forwardRef<SCWidgetRef, SCWidgetProps>(
  function SCWidget(props, ref) {
    const {
      url,
      width = "100%",
      height = 166,
      style,
      className,
      iframeId,
      onReady,
      onPlay,
      onPause,
      onFinish,
      onSeek,
      onPlayProgress,
      onLoadProgress,
      onError,
      onClickDownload,
      onClickBuy,
      onOpenSharePanel,
      ...params
    } = props;

    const { loaded } = useScript();
    const iframeRef = useRef<HTMLIFrameElement>(null);
    const widgetRef = useRef<SCWidgetInstance | null>(null);
    const initializedRef = useRef(false);
    const generatedId = useId();
    const frameId = iframeId ?? `sc-widget-${generatedId}`;

    // Stable refs for callbacks so effects don't re-run on each render
    const callbacksRef = useRef({
      onReady,
      onPlay,
      onPause,
      onFinish,
      onSeek,
      onPlayProgress,
      onLoadProgress,
      onError,
      onClickDownload,
      onClickBuy,
      onOpenSharePanel,
    });
    useEffect(() => {
      callbacksRef.current = {
        onReady,
        onPlay,
        onPause,
        onFinish,
        onSeek,
        onPlayProgress,
        onLoadProgress,
        onError,
        onClickDownload,
        onClickBuy,
        onOpenSharePanel,
      };
    });

    // Initialize widget once script is loaded and iframe is mounted
    useEffect(() => {
      if (!loaded || !iframeRef.current || initializedRef.current) return;

      const widget = window.SC.Widget(iframeRef.current);
      widgetRef.current = widget;
      initializedRef.current = true;

      const handlers: Array<[string, (e?: SCAudioEventPayload) => void]> = [
        ["ready", () => callbacksRef.current.onReady?.()],
        ["play", (e) => callbacksRef.current.onPlay?.(e as SCAudioEventPayload)],
        ["pause", (e) => callbacksRef.current.onPause?.(e as SCAudioEventPayload)],
        ["finish", (e) => callbacksRef.current.onFinish?.(e as SCAudioEventPayload)],
        ["seek", (e) => callbacksRef.current.onSeek?.(e as SCAudioEventPayload)],
        ["play_progress", (e) => callbacksRef.current.onPlayProgress?.(e as SCAudioEventPayload)],
        ["load_progress", (e) => callbacksRef.current.onLoadProgress?.(e as SCAudioEventPayload)],
        ["error", () => callbacksRef.current.onError?.()],
        ["click_download", () => callbacksRef.current.onClickDownload?.()],
        ["click_buy", () => callbacksRef.current.onClickBuy?.()],
        ["open_share_panel", () => callbacksRef.current.onOpenSharePanel?.()],
      ];

      for (const [event, handler] of handlers) {
        widget.bind(event, handler);
      }

      return () => {
        for (const [event] of handlers) {
          widget.unbind(event);
        }
        widgetRef.current = null;
        initializedRef.current = false;
      };
    }, [loaded]);

    // Reload when url or params change (after initial mount)
    const isFirstRender = useRef(true);
    const prevUrl = useRef(url);
    const prevParams = useRef(params);

    useEffect(() => {
      if (isFirstRender.current) {
        isFirstRender.current = false;
        prevUrl.current = url;
        prevParams.current = params;
        return;
      }

      if (!widgetRef.current) return;

      prevUrl.current = url;
      prevParams.current = params;

      widgetRef.current.load(url, {
        ...params,
        callback: callbacksRef.current.onReady,
      });
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [url, params.autoPlay, params.color, params.buying, params.sharing,
        params.download, params.showArtwork, params.showPlaycount, params.showUser,
        params.startTrack, params.singleActive, params.showTeaser]);

    useImperativeHandle(ref, () => ({
      play: () => widgetRef.current?.play(),
      pause: () => widgetRef.current?.pause(),
      toggle: () => widgetRef.current?.toggle(),
      seekTo: (ms) => widgetRef.current?.seekTo(ms),
      setVolume: (vol) => widgetRef.current?.setVolume(vol),
      next: () => widgetRef.current?.next(),
      prev: () => widgetRef.current?.prev(),
      skip: (idx) => widgetRef.current?.skip(idx),
      load: (u, opts) => widgetRef.current?.load(u, opts),
      getVolume: (cb) => widgetRef.current?.getVolume(cb) ?? cb(0),
      getDuration: (cb) => widgetRef.current?.getDuration(cb) ?? cb(0),
      getPosition: (cb) => widgetRef.current?.getPosition(cb) ?? cb(0),
      getSounds: (cb) => widgetRef.current?.getSounds(cb) ?? cb([]),
      getCurrentSound: (cb) => widgetRef.current?.getCurrentSound(cb),
      getCurrentSoundIndex: (cb) => widgetRef.current?.getCurrentSoundIndex(cb) ?? cb(0),
      isPaused: (cb) => widgetRef.current?.isPaused(cb) ?? cb(true),
    }));

    const src = buildIframeSrc(url, extractParams(props));

    return (
      <iframe
        ref={iframeRef}
        id={frameId}
        src={src}
        width={width}
        height={height}
        style={style}
        className={className}
        scrolling="no"
        frameBorder="no"
        allow="autoplay"
      />
    );
  }
);

SCWidget.displayName = "SCWidget";

export default SCWidget;

---

# src/index.ts
export { SCWidget } from "./SCWidget";
export { SCWidget as default } from "./SCWidget";
export type {
  SCWidgetRef,
  SCWidgetProps,
  SCWidgetParams,
  SCAudioEventPayload,
  SCSound,
  SCWidgetInstance,
} from "./types";

---

# Changelog

All notable changes to `soundcloud-widget-react` are documented here.

---

## [1.0.7] — 2026-02-24

### Fixed
- **Script detection compatibility** — `useScript` now checks for an existing `window.SC` object before attempting to add another `<script>` tag. This fixes a bug where the widget would silently fail to initialize (and crash on unmount) when the SoundCloud Widget API had already been loaded via a framework script loader (e.g. Next.js `<Script strategy="beforeInteractive">`). A poll-based fallback handles the case where the script tag is already in the DOM but not yet executed.

---

## [1.0.6] — 2026-02-24

### Fixed
- Added `repository` field to `package.json` — required for npm provenance verification (`--provenance` flag). Without it, publishes would fail with a sigstore E422.

### CI
- Removed `registry-url` from `actions/setup-node` in publish workflow — it was overriding the GitHub OIDC token exchange needed for npm Trusted Publishing.

---

## [1.0.5] — 2026-02-24

### CI
- Test run for npm Trusted Publishing (OIDC) flow.

---

## [1.0.4] — 2026-02-24

### CI
- Removed stale `NPM_TOKEN` GitHub secret; switched to pure OIDC token path.

---

## [1.0.3] — 2026-02-24

### CI
- Re-added `registry-url` to diagnose OIDC auth issues (superseded by 1.0.6 fix).

---

## [1.0.2] — 2026-02-24

### CI
- Switched publish workflow to npm Trusted Publishing (`id-token: write`, `--provenance`).

---

## [1.0.1] — 2026-02-24

### Initial release
- `SCWidget` React component wrapping the SoundCloud HTML5 Widget API
- Full TypeScript types: `SCWidgetProps`, `SCWidgetRef`, `SCWidgetParams`, `SCAudioEventPayload`, `SCSound`, `SCWidgetInstance`
- `forwardRef` support with full imperative API (`play`, `pause`, `toggle`, `seekTo`, `setVolume`, `next`, `prev`, `skip`, `load`, `getVolume`, `getDuration`, `getPosition`, `getSounds`, `getCurrentSound`, `getCurrentSoundIndex`, `isPaused`)
- All Widget API events: `onReady`, `onPlay`, `onPause`, `onFinish`, `onSeek`, `onPlayProgress`, `onLoadProgress`, `onError`, `onClickDownload`, `onClickBuy`, `onOpenSharePanel`
- Stable callback refs — event handlers update without re-binding the widget
- URL/param change detection via `widget.load()` (no iframe remount)
- Dynamic script loading via `useScript` hook (singleton, deduped)
- ESM + CJS dual build, full `.d.ts` declarations
- MIT license
