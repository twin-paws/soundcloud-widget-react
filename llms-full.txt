# soundcloud-widget-react — Full Reference

The definitive React wrapper for the SoundCloud HTML5 Widget API.
Version: 2.0.0 | License: MIT | npm: soundcloud-widget-react
Peer deps: react >= 17, react-dom >= 17 | Zero runtime dependencies

---

# src/types.ts

import type { CSSProperties, HTMLAttributeReferrerPolicy } from "react";

export enum SCWidgetEvents {
  READY = "ready",
  PLAY = "play",
  PAUSE = "pause",
  FINISH = "finish",
  SEEK = "seek",
  PLAY_PROGRESS = "play_progress",
  LOAD_PROGRESS = "load_progress",
  CLICK_BUY = "click_buy",
  CLICK_DOWNLOAD = "click_download",
  OPEN_SHARE_PANEL = "open_share_panel",
  ERROR = "error",
}

export interface SCWidgetParams {
  autoPlay?: boolean;
  color?: string;
  buying?: boolean;
  sharing?: boolean;
  download?: boolean;
  showArtwork?: boolean;
  showPlaycount?: boolean;
  showUser?: boolean;
  startTrack?: number;
  singleActive?: boolean;
  showTeaser?: boolean;
  visual?: boolean;
  liking?: boolean;
  showComments?: boolean;
  hideRelated?: boolean;
}

export interface SCAudioEventPayload {
  relativePosition: number;  // 0-1
  loadProgress: number;      // 0-1
  currentPosition: number;   // milliseconds
}

export interface SCSound {
  id: number;
  title: string;
  permalink_url: string;
  artwork_url: string | null;
  user: { username: string; permalink_url: string };
  duration: number;
}

export interface SCWidgetInstance {
  bind(eventName: string, listener: (e?: SCAudioEventPayload) => void): void;
  unbind(eventName: string): void;
  load(url: string, options?: Partial<SCWidgetParams> & { callback?: () => void }): void;
  play(): void;
  pause(): void;
  toggle(): void;
  seekTo(milliseconds: number): void;
  setVolume(volume: number): void;
  next(): void;
  prev(): void;
  skip(soundIndex: number): void;
  getVolume(callback: (volume: number) => void): void;
  getDuration(callback: (duration: number) => void): void;
  getPosition(callback: (position: number) => void): void;
  getSounds(callback: (sounds: SCSound[]) => void): void;
  getCurrentSound(callback: (sound: SCSound) => void): void;
  getCurrentSoundIndex(callback: (index: number) => void): void;
  isPaused(callback: (paused: boolean) => void): void;
}

export type SCWidgetEventMap = {
  [SCWidgetEvents.READY]: undefined;
  [SCWidgetEvents.PLAY]: SCAudioEventPayload;
  [SCWidgetEvents.PAUSE]: SCAudioEventPayload;
  [SCWidgetEvents.FINISH]: SCAudioEventPayload;
  [SCWidgetEvents.SEEK]: SCAudioEventPayload;
  [SCWidgetEvents.PLAY_PROGRESS]: SCAudioEventPayload;
  [SCWidgetEvents.LOAD_PROGRESS]: SCAudioEventPayload;
  [SCWidgetEvents.CLICK_BUY]: undefined;
  [SCWidgetEvents.CLICK_DOWNLOAD]: undefined;
  [SCWidgetEvents.OPEN_SHARE_PANEL]: undefined;
  [SCWidgetEvents.ERROR]: undefined;
};

export interface SCWidgetRef {
  // Controls
  play(): void;
  pause(): void;
  toggle(): void;
  seekTo(milliseconds: number): void;
  setVolume(volume: number): void;
  next(): void;
  prev(): void;
  skip(soundIndex: number): void;
  load(url: string, options?: Partial<SCWidgetParams> & { callback?: () => void }): void;
  // Callback-style getters
  getVolume(callback: (volume: number) => void): void;
  getDuration(callback: (duration: number) => void): void;
  getPosition(callback: (position: number) => void): void;
  getSounds(callback: (sounds: SCSound[]) => void): void;
  getCurrentSound(callback: (sound: SCSound) => void): void;
  getCurrentSoundIndex(callback: (index: number) => void): void;
  isPaused(callback: (paused: boolean) => void): void;
  // Promise-based getters (v2)
  getDurationAsync(): Promise<number>;
  getPositionAsync(): Promise<number>;
  getVolumeAsync(): Promise<number>;
  getSoundsAsync(): Promise<SCSound[]>;
  getCurrentSoundAsync(): Promise<SCSound>;
  getCurrentSoundIndexAsync(): Promise<number>;
  isPausedAsync(): Promise<boolean>;
}

export interface SCWidgetProps extends SCWidgetParams {
  url: string;
  width?: string | number;
  height?: string | number;
  style?: CSSProperties;
  className?: string;
  iframeId?: string;
  // iframe attributes
  title?: string;
  loading?: "eager" | "lazy";
  allow?: string;           // default: "autoplay"
  sandbox?: string;
  referrerPolicy?: HTMLAttributeReferrerPolicy;
  hidden?: boolean;         // render 1x1 invisible iframe, ignores layout props
  // Named event handlers
  onReady?: (ctx: { widget: SCWidgetInstance }) => void;
  onPlay?: (e: SCAudioEventPayload) => void;
  onPause?: (e: SCAudioEventPayload) => void;
  onFinish?: (e: SCAudioEventPayload) => void;
  onSeek?: (e: SCAudioEventPayload) => void;
  onPlayProgress?: (e: SCAudioEventPayload) => void;
  onLoadProgress?: (e: SCAudioEventPayload) => void;
  onError?: () => void;
  onClickDownload?: () => void;
  onClickBuy?: () => void;
  onOpenSharePanel?: () => void;
  // Generic event map (additive with named handlers)
  onEvent?: { [K in SCWidgetEvents]?: (payload: SCWidgetEventMap[K]) => void };
}

export interface SCWidgetState {
  isReady: boolean;
  isPlaying: boolean;
  positionMs: number;
  durationMs: number;
  sound: SCSound | null;
  soundIndex: number;
}

---

# src/useScript.ts

Singleton script loader. Deduplicates across multiple widget mounts.
Returns: { loaded: boolean; error: Error | null }

Handles:
- window.SC already present (beforeInteractive Next.js Script)
- Script tag in DOM but not yet executed (polls until window.SC appears, 10s timeout)
- Network/CSP errors (resets singleton, surfaces via error state)
- Unmount before resolve (mounted flag prevents state updates on dead components)

---

# src/SCWidget.tsx

forwardRef component. Key behaviors:
- Builds iframe src via URLSearchParams (no double-encoding)
- Initializes SC.Widget once script loaded + iframe mounted (singleton init guard)
- Binds all 11 Widget API events; calls both named prop AND onEvent[event] (additive)
- onReady passes { widget: SCWidgetInstance } to handler
- Stable callback refs — handlers update without re-binding the widget
- URL/param changes call widget.load() — no iframe remount
- hidden=true: renders position:absolute, 1x1px, visibility:hidden, pointerEvents:none
- allow defaults to "autoplay" if not provided

---

# src/useSCWidget.ts

Hook signature:
  useSCWidget(): { ref, state, props, controls }

ref: React.RefObject<SCWidgetRef | null> — pass to <SCWidget ref={ref} />
state: SCWidgetState — reactive, driven by widget events
props: Pick<SCWidgetProps, "onReady"|"onPlay"|"onPause"|"onFinish"|"onPlayProgress"> — spread onto <SCWidget>
controls: { play, pause, toggle, seekTo, setVolume, next, prev, skip, load } — all stable useCallback refs

State updates:
- onReady: fetches durationMs, sound, soundIndex via async getters; sets isReady=true
- onPlay: isPlaying=true
- onPause/onFinish: isPlaying=false
- onPlayProgress: positionMs=e.currentPosition

---

# src/index.ts

export { SCWidget } from "./SCWidget";
export { SCWidget as default } from "./SCWidget";
export { useSCWidget } from "./useSCWidget";
export { SCWidgetEvents } from "./types";
export type {
  SCWidgetRef, SCWidgetProps, SCWidgetParams, SCAudioEventPayload,
  SCSound, SCWidgetInstance, SCWidgetState, SCWidgetEventMap,
} from "./types";

---

# Usage Examples

## Basic
<SCWidget url="https://soundcloud.com/artist/track" onReady={({ widget }) => console.log(widget)} />

## useSCWidget (recommended)
const { ref, state, props, controls } = useSCWidget();
<SCWidget ref={ref} url="..." {...props} />
<button onClick={controls.play}>{state.isPlaying ? "Pause" : "Play"}</button>
<span>{Math.round(state.positionMs / 1000)}s / {Math.round(state.durationMs / 1000)}s</span>

## Generic onEvent
<SCWidget url="..." onEvent={{
  [SCWidgetEvents.PLAY]: (e) => console.log("play", e.currentPosition),
  [SCWidgetEvents.ERROR]: () => handleError(),
}} />

## Hidden/controller-only
<SCWidget ref={ref} url="..." hidden autoPlay {...props} />

## Promise getter
const duration = await playerRef.current?.getDurationAsync() ?? 0;

## Next.js Option A
dynamic(() => import("soundcloud-widget-react").then(m => m.SCWidget), { ssr: false })

## Next.js Option B (root layout)
<Script strategy="beforeInteractive" src="https://w.soundcloud.com/player/api.js" />
// then use <SCWidget> directly in "use client" components

---

# Migration: v1 -> v2

BREAKING: onReady signature changed from `() => void` to `(ctx: { widget: SCWidgetInstance }) => void`
Update: onReady={() => ...}  =>  onReady={({ widget }) => ...}

NEW exports: useSCWidget, SCWidgetEvents, SCWidgetState, SCWidgetEventMap
NEW props: onEvent, title, loading, allow, sandbox, referrerPolicy, hidden, visual, liking, showComments, hideRelated
NEW ref methods: *Async() Promise variants

---

# Known Limitations

- Instagram in-app browser: blocks autoplay, play() must be from user gesture. Show fallback button.
- CSP: add frame-src https://w.soundcloud.com and script-src https://w.soundcloud.com
